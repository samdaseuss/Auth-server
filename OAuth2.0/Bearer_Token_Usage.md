# Bearer Token 사용법

``` text
본 내용은 "The OAuth 2.0 Authorization Framework: Bearer Token Usage [RFC6750]" 문서를 한국어 이용자가 이해하기 쉽도록 2차 가공해 번역한 문서이기 때문에 원문에 없는 부가 설명이 들어가있거나 원문과 문장의 배치가 상이할 수 있습니다.
또한 Authorization을 해석할 때 '인가'라는 용어 대신 '접근 권한' 혹은 '접근 권한 부여'라는 용어를 사용하기도 합니다. 이는 글의 가독성을 높이기 위함입니다.
```

본 내용은 HTTP 요청 상황에서 'OAuth 2.0에 의해 보호되는 서버 리소스에 어떻게 접근할 것인가'에 대한 많은 방법 중 `bearer 토큰`을 이용하는 방법에 대해 다룹니다. 이 bearer 토큰을 가지고 있는 사람이라면 누구나 서버에서 원하는 자원에 접근하는 것이 가능하죠. ( cryptographoc key의 소유를 드러내지 않아도 말이에요. ) 

부적절한 사용을 방지하기 위해, bearer 토큰은 저장과 전송 과정 중에 절때 노출되어서는 안됩니다.

**목차**

```toc
```



## 들어가기전
엑세스 토큰이라는 것을 얻음으로써 보호되어있는 리소스에 클라이언트의 접근을 가능하게 하는 것이 `OAuth`라는 것이지요. OAuth 2.0 Authorization Framwork 문서에서는 엑세스 토큰에 대해 클라이언트에게 부여된 접근 권한를 나타내는 문자열이라고 정의했어요. 덕분에 우리는 리소스를 가지고 있는 서버의 자격 증명을 직접 받는 방식이 아닌 엑세스 토큰을 사용해 접근을 할 수 있습니다. ( 더 자세한 내용은 "OAuth 2.0  권한 부여 프레임워크 [RFC6749]"를 참고하세요 )

토큰은 리소스 소유자의 승인을 받은 `인가 서버`에서 `클라이언트`로 발급됩니다. 클라이언트는 인가 서버로 부터 받은 액세스 토큰을 가지고 리소스 서버에서 호스팅 되고있는 보호된 리소스에 접근할 수 있습니다. 여기서는 OAuth 액세스 토큰이 Bearer 토큰일 경우 보호된 리소스 요청을 어떻게 수행하는지 설명합니다.

이 명세서는 TLS (전송 계층 보안) [RFC5246]을 사용하여 HTTP/1.1 [RFC2616]을 통해 즉, HTTPS를 통해 베어러 토큰을 사용하여 보호된 리소스에 액세스하는 방법을 정의합니다. 여기에서는 암호화 방법으로 TLS가 구현되어 사용되어야 하며, 다른 명세서에서는 다른 프로토콜에 사용하도록이 명세서를 확장할 수 있습니다. 이 명세서는 OAuth 2.0 인가 [RFC6749] 흐름에서 액세스 토큰을 사용하여 OAuth 보호된 리소스에 액세스하기 위해 설계되었지만, 실제로는 베어러 토큰을 사용하여 보호된 모든 리소스에 액세스할 수 있는 일반적인 HTTP 인증 방법을 정의합니다. 베어러 인증 체계는 주로 `WWW-Authenticate` 및 `Authorization` HTTP 헤더를 사용하여 서버 인증에 사용되지만 프록시 인증에도 사용할 수 있습니다.

### 표기 관례

### 용어
**Bearer token (베어러 토큰)**
"bearer"라는 토큰을 소유한 자라면 누구나 이 토큰을 가진 다른 사람들과 같은 권한을 가진다는 보안 토큰. 토큰의 `소유가 곧 증명`이기 때문에 소유자는 Bearer 토큰을 사용하기 위해서 암호화 키 자료의 소유를 증명할 필요가 없습니다. ( `proof-of-possesion` , 증명-소유 방식)

이 외의 용어는 "OAuth 2.0 Authorization Framework" [RFC6749]에서 정의하고 있는 것과 동일합니다.

### 개요
OAuth는 리소스의 원래 소유자를 대신해 클라이언트에게 보호된 리소스에 접근할 수 있게 해줍니다. 클라이언트가 보호된 리소스에 접근하기 전 대개의 경우에는 리소스 소유자로부터 먼저 권한 부여를 받은 후에 이 발급된 권한을 access token과 교환하는 방식으로 진행됩니다.

엑세스 토큰이라는 것은 `부여된 권한의 범위`, `사용 기간`, `인가 부여`로 인해 부여되는 기타 속성을 나타냅니다. 클라이언트는 이 액세스 토큰을 리소스 서버에 제시함으로써 보호된 리소스에 접근할 수 있습니다. 경우에 따라 클라이언트는 리소스 소유자로부터 인가 부여를 먼저 받지 않고도 엑세스 토큰을 얻을 수 있습니다. 직접 자신의 자격 증명을 인가 서버에 제시함으로써 말이죠.

엑세스 토큰은 추상화를 제공합니다. 유저 아이디와 패스워드 등과 같은 다양한 인가 방식을 추상화 하기 때문에  리소스 서버가 다양한 인증 체계를 모두 알고 이해하고 있어야 될 필요가 없어집니다. 또한 엑세스 토큰은 짧은 시간 동안만 유효하기 때문에 보안성도 높다는 이점이 있습니다.

```Note
💡 엑세스 토큰은 리소스 서버가 다양한 인증 방식을 이해하지 않아도 되게 하고, 단일 토큰으로 여러 인가 구조를 대체하여 보안성을 높이며 유효 기간을 관리하는 장점을 제공
```
아래는 클라이언트(Client)와 리소스 소유자(Resource Owner) ,권한 부여 서버(Authorization Server) 그리고 리소스 서버(Resource Server) 사이의 관계를 나타낸 OAuth 2.0의 전체적인 추상화 흐름도 입니다.

	+--------+                               +---------------+
	|        |--(A)- Authorization Request ->|   Resource    |
	|        |                               |     Owner     |
	|        |<-(B)-- Authorization Grant ---|               |
	|        |                               +---------------+
	|        |
	|        |                               +---------------+
	|        |--(C)-- Authorization Grant -->| Authorization |
	| Client |                               |     Server    |
	|        |<-(D)----- Access Token -------|               |
	|        |                               +---------------+
	|        |
	|        |                               +---------------+
	|        |--(E)----- Access Token ------>|    Resource   |
	|        |                               |     Server    |
	|        |<-(F)--- Protected Resource ---|               |
	+--------+                               +---------------+
					 Figure 1: Abstract Protocol Flow
(A)부터 (D)는 엑세스 토큰 발급 과정을 나타낸 것이고 (E)부터 (F)는 발급받은 엑세스 토큰을 사용해 서버의 리소스에 접근하는 과정을 나타낸 것이 되겠습니다.

**[Client <--> Resource Owner]**

(A) 클라이언트의 권한 부여 요청

(B) 리소스 소유자의 권한 부여 승인

**[Client <--> Authorization Server]**

(C) 클라이언트가 리소스 소유자에게 받은 권한 부여 승인을 권한 부여하는 서버에게 제출

(D) 권한 부여 서버가 엑세스 토큰을 발급해 클라이언트에게 전달

**[Client <--> Resource Server]**

(E) 클라이언트가 발급된 엑세스 토큰으로 리소스 서버에서 리소스 접근하려 시도

(F) 리소스 서버는 클라이언트 엑세스 토큰을 확인하고 해당 리소스 제공

## 인증된 요청
이번 인증된 요청 섹션에서는 서버에 리소스를 요청할 때 필요한 베어러 엑세스 토큰(bearer access token)을 보내는 세 가지 방법을 정의합니다. 이때 클라이언트가 주의해야할 점은 토큰 전송 요청을 보낼 때 하나 이상의 방법을 사용해서는 안된다는 것 입니다.

### Authorization 요청 헤더 필드에 담아 보내기
엑세스 토큰을 Authorization 요청 헤더 필드에 담아 보낼 때는 클라이언트는 엑세스 토큰을 전송하기 위해 Bearer 라는 인증 스킴을 사용합니다. ( 인증 스킴은 이해하기 쉽게 인증 키워드라고 생각하면 되나 사실 인증 프로토콜이라고 하는게 조금 더 정확하겠습니다. ) 아래 예시를 볼까요?
```HTTP/1.1
GET /response HTTP/1.1
HOST: server.example.com
Authorization: Bearer mF_9.B5f-4.1JqM
```
Authorization 헤더 필드의 구문은 Basic 스킴을 사용합니다. (Basic 스킴에 대한 자세한 내용은 `RFC2617`의 섹션 2 부분 참고) 여기서 중요하게 짚고 넘어가야 할 부분은 이 구문은 권장되는 방법과는 다른 방식으로 구현되었다는 것입니다. 이는 기존의 배포 기술 (이전에 구축된 시스템과의 호환성)을 고려하기 위함으로  RFC2617 섹션1.2에서 정의하고 있는 사용하기를 '권장하는' 구문에는 부합하지 않지만 HTTP 1.1을 위해 개발중인 일반적인 프레임워크와는 호환됩니다.

자격 증명의 보유자가 Bearer 방식을 사용하는 것을 Bearer 자격 증명(Bearer credential)이라고 합니다. Bearer Credential의 구문은 다음과 같이 사용됩니다.
```
b64token    = 1*( ALPHA / DIGIT / "-" / "." / "_" / "~" / "+" / "/" ) *"="
credentials = "Bearer" 1*SP b64token
```
b64token은 base64방식으로 인코딩된 문자열을 나타내는 정규식입니다. 이를 해석하면 다음과 같습니다.
- 1*          : 최소 한 글자 이상으로 이루어진 문자열이어야 한다.
- ( ALPHA / DIGIT / "-" / "." / "\_" / "~" / "+" / "/" )
	- ALPHA : 알파벳 대문자나 소문자 포함
	- DIGIT    : 0 ~ 1까지의 숫자 포함
- "="        : 마지막 = 으로 끝나는 것 허용
위의 모든 조건을 합치면 문자열은 최소 한 글자 이상으로 이루어져있고 알파벳 대소문자, 숫자, -, ., \_, ~, +, / 를 포함할 수 있고 그 뒤에  =이 포함되거나 포함되지 않은 문자열이 올 수 있다는 결론에 다다릅니다.

### Form-Encoded 바디 파라미터에 담아 보내기
엔티티 바디에 엑세스 토큰을 담아 보낼때 클라이언트는 `access_token` 파라미터를 사용하면 됩니다. 하지만 이 방법은 아래 조건들이 모두 만족하는 경우가 아니라면 사용해서는 안됩니다.

- HTTP 요청 엔티티 헤더에  `Content-Type` 헤더 필드가  포함되어있으며 이 필드의 값이 `application/x-www-form-urlencoded`로 설정되어있어야 함 ( = 요청이 폼 데이터를 전송하는데 사용되고, "application/x-www-form-urlencoded" 형식으로 인코딩 되어있음을 의미 )
- 엔티티 바디는  HTML 4.01 [W3C.REC-html401-19991224]에서 정의된 "application/x-www-form-urlencoded" 콘텐트 유형(content-type)의 인코딩 요구 사항을 따른다.
- HTTP 요청의 엔티티 바디는 `multipart`가 아닌 `single-part`로 구성되어야함
- 엔티티 바디에 인코딩 될 콘텐츠는 전부 ASCII 문자로만 이루어져야함
- HTTP 요청 메서드 중에서도 요청 본문에 정의된 내용이 의미가 있는 메서드를 사용해야 함. 이는 곧 GET 메서드가 사용될 수 없다는 것을 의미
```text
💡 HTTP 요청 메서드 중에는 요청 본문이 없는 메서드도 있지만, 요청 본문을 포함하는 메서드도 있습니다. 이러한 메서드 중에서는 요청 본문에 따른 특정 의미가 정의된 메서드도 있습니다.
 그 중에서도 "GET" 메서드는 요청 본문을 전송하지 않기 때문에, 이 메서드를 사용하여 요청 본문을 전송하는 것은 허용되지 않습니다. 따라서 "GET" 메서드는 요청 본문이 정의된 의미가 있는 메서드가 아니며, 요청 본문을 전송할 때에는 다른 메서드를 사용해야 합니다.
```
엔티티 바디에는 `access_token`으로 표현되는 엑세스 토큰 파라미터 말고도 다른 요청 세부정보를 담은 파라미터들을 포함하고 있을 것입니다.  이 경우 반드시 `&` 문자를 이용해 access_token 파라미터와 다른 파라미터를 구분해줘야합니다. ( & 문자는 아스키코드 38번에 해당됩니다. )

아래는 클리이언트가 TLS 보안 프로토콜을 사용해 HTTP 요청을 보낸 상황입니다.
```HTTP/1.1
POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=mF_9.B5f-4.1JqM
```
application/x-www-form-urlencoded 방식은 요청에 참여하는 브라우저가 "Authorization" 요청 헤더 필드에 액세스 할 수 없는 에플리케이션 컨텍스트 상에서만 사용되어야합니다. 리소스 서버가 이 기능을 지원합니다.


### URI 쿼리 파라미터에 담아 보내기
이번에는 요청 URI에 엑세스 토큰을 담아 보내려고 합니다. 어떻게 해야할까요? 클라이언트가 요청을 보낼 때 요청 URI 쿼리 컴포넌트에 엑세스토큰을 추가해 보내면 됩니다.( URI에 대한 더 자세한 내용은 [RFC3986]를 참고 ) 이것을 URI 방법이라고 합니다. URI 방법은 간단히 말해 엑세스 토큰을 URL에 포함시키는 방법입니다.

예를 들어볼까요? 클라이언트가 다음 TLS 프로토콜로 HTTP 요청을 보내는 상황이 있다고 해봅시다.

```
GET /resource?access_token=mF_9.B5f-4.1J1M HTTP/1.1
Host: server.example.com
```

HTTP 요청 URI 쿼리에는 access_token 파라미터 외에 다른 요청 세부정보를 담은 파라미터도 포함하겠죠? `&` 문자열을 사용해 반드시 구별해줘야 합니다. 

```
http://server.example.com/resource?access_token=mF_9.B5f-4.1JqM&p=q
```

URI 쿼리 파라미터 방법을 사용할 때 클라이언트 쪽에서 `Cache-Control` 헤더에 `no-store` 옵션을 추가하길 권장하고 있습니다. 또한 클라이언트의 요청에 대해 200대 성공 상태메시지를 응답 상태 값으로 반환하는 서버도 응답할때 `Cache-Control` 헤더에 `private` 옵션을 추가해야합니다.

로그에 URL이 기록되는 등의 보안상 약점 때문에 사용이 권장되지는 않습니다. 따라서 Authorization 요청 헤더 필드나 HTTP 요청 엔티티 바디로 엑세스 토큰을 전송하지 못하는 경우를 제외하고는 이 방법을 사용하지 않기를 권장합니다. 리소스 서버에서 이 기능을 지원합니다. ( URI 보안 약점 대한 자세한 내용은 이 본문 섹션 5번을 보면 됩니다.)

이 방법이 보안상 좋지 않고 URI 네임스페이스 최선의 사용법에 어긋나기 때문에 사용이 권장되지 않음에도 불구하고("Architecture of the World Wide Web, Volume One" [W3C.REC-webarch-20041215] 참고) 문서에 사용 방법을 언급하고 있는 이유는 URI 방법이 현재 사용되는 방법이기 때문입니다. 다만 이보다 더 안전한 방법인 위의 두 방법(헤더 혹은 바디로 보내는 방법)을 사용하는 것이 좋겠습니다.


## WWW-Authenticate 응답 헤더 필드
만약 서버로 오는 요청에 `인증 증명서`나 `엑세스 토큰`이 포함 되어있지 않다면 리소스 서버는 `WWW-Authenticate` 응답 헤더 필드를 반드시 추가할 필요가 있습니다. ( ※ 꼭 이 경우가 아니더라도 WWW-Authenticate 헤더 사용 가능 ) WWW-Authenticate 헤더 필드는 HTTP/1.1[RFC2617]에서 정의하고 있는 프레임워크를 사용하고 있습니다.
이 글에 정의되어있는 모든 예제들은 `Bearer` 인증 체계 값이 사용되어야 하며, 이 스키마를 쓸 땐 반드시 하나 이상의 인증 속성 값 (auth-param)을 포함되어야 합니다. 아래에서 이 글에 쓰인 auth-param 속성을 몇가지 알아봅시다. 이 외에 다른 auth-param 속성도 쓰일 수 있다는 것을 알아두세요.
``` summary
💡 이 글에서 정의된 인증에는 "Bearer" 인증 체계 값과 이에 따라 적용되는 auth-param 속성이 포함되어야 하며, 다른 속성도 사용 가능합니다.
```

**realm**
HTTP/1.1 [RFC2617]에서 설명된 방식과 동일하게, 보호 범위를 나타내기 위해 `realm`  속성 포함 할 수 있습니다. 하지만 이 속성은 한번 이상 중복으로 쓰일 수 없습니다. ( 인증의 정확성과 일관성을 유지하기 위해서 )
```
예를 들어, 동일한 웹사이트에서 블로그, 포럼, 게시판 등 여러 개의 애플리케이션이 보호되는 자원에 접근하는 경우, 각각의 애플리케이션마다 별도의 보호 범위를 지정할 수 있습니다.

이때, realm 속성을 사용하여 각각의 애플리케이션마다 고유한 보호 범위를 설정할 수 있습니다. 예를 들어, 블로그의 경우 "realm=blog"로 지정하고, 포럼의 경우 "realm=forum"으로 지정할 수 있습니다.

이렇게 realm 속성을 사용하면, 사용자가 로그인하여 인증된 후에도 다른 애플리케이션의 자원에 접근하려고 할 때, 각각의 애플리케이션마다 다시 인증 과정을 거쳐야 합니다. 이를 통해 보안성을 높일 수 있습니다.
```


**scope**
`scope` 속성 같은 경우는 [RFC6749] 섹션 3.3에 정의되어 있습니다. 요청된 리소스에 대한 액세스 토큰의 필요한 범위를 나타내는 대소문자를 구분하는 범위 값의 공백으로 구분된 목록입니다. "scope" 값은 구현에 따라 정의되며, 이에 대한 중앙 레지스트리는 없습니다. "scope" 값의 순서는 중요하지 않습니다. "scope" 값은 충분한 액세스 권한이 있는 새 액세스 토큰을 요청할 때 보호된 리소스를 사용하기 위해 사용될 수 있습니다. "scope" 속성의 사용은 선택적입니다. "scope" 속성은 한 번 이상 나타날 수 없습니다. "scope" 값은 프로그래밍적인 용도로 만들어졌으며, 엔드유저에게 표시되는 것이 아닙니다.
아래에 2가지 예시를 들어보겠습니다.
```
scope="openid profile email"
scope="urn:example:channel=HBO&urn:example:rating=G,PG-13"
```

만약 보호된 리소스 요청이 엑세스 토큰을 포함하고 있는데 인증에 실패했다면 리소스 서버는 클라이언트에게 왜 엑세스가 거부되었는지 이유를 담은 에러 요소를 포함해야합니다. 파라미터 값이 바로이어지는 섹션 3.1에 설명되어있습니다. 추가적으로 리소스 서버는 개발자에게 인간이 읽을 수 있는 형태의 에러 설명을 제공하기 위해  `error_description` 요소를 포함할 수도 있습니다. 또한 "error_uri" 속성을 포함할 수도 있으며, 이는 오류를 설명하는 인간이 읽을 수 있는 웹 페이지를 식별하는 절대 URI입니다.
`error`, `error_description`그리고 `error_uri` 요소는 중복해서 사용할 수 없습니다.

[ 요소의 값으로 사용할 수 없는 것들에 대하여 ]  
`scope` 요소의 값은 다음 문자열 외에는 사용해서는 안됩니다. 
```
[RFC6749 부록 A.4]
범위의 값을 나타내는 문자 세트
%x21 / %x23-5B / %x5D-7E
범위 값 사이의 구분자로 사용되는 값
%x20
```

`error` 및 `error_description` 요소의 값도 다음 문자세트를 벗어나는 문자열 포함할 수 없습니다.
```
[RFC6749 부록 A.7 및 A.8]
%x20-21 / %x23-5B / %x5D-7E
```

`error_uri` 속성에 대한 값은 URI-reference 구문을 준수해야하므로 다음 문자열을 벗어나는 문자열을 포함할 수 없습니다.

```
[RFC6749 부록 A.9]
%x21 / %x23-5B / %x5D-7E
```

아래 예시는 별도의 인증 없이 보호된 리소스를 요청했을때 돌아오는 응답값입니다.
```
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="example"
```

만약 만료된 액세스 토큰을 사용하여 인증 시도를 수행한 보호된 리소스 요청에 대한 응답이 있다면 다음과 같습니다.
```
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="example"
				  error="invalid_token",
				  error_description="The access token expired"
```

### 에러 코드
요청이 실패하면 리소스 서버는 400, 401, 403, 405 와 같은 적절한 HTTP 상태 코드를 응답해줍니다. 또한 아래 에러 코드를 포함해줍니다.

Invalid_request
```
유효하지 않은 요청
이 요청은 필수 파라미터를 누락했거나 지원하지 않는 파라미터를 보냈거나 파라미터를 중복해서 보냈거나 엑세스 토큰을 보내는 방식이 1개 이상이거나 다른 방식으로 형식이 올바르지 않은 경우 발생한다.리소스 서버는 "invalid_request" 오류가 발생한 경우 HTTP 400 (잘못된 요청) 상태 코드와 함께 응답해야함
```

invalid_token
```
금지된 토큰
제공된 액세스 토큰이 만료되었거나 폐기되었거나 형식이 잘못되었거나 기타 이유로 유효하지 않은 경우에 발생합니다.
리소스 서버는 "invalid_token" 오류가 발생한 경우 HTTP 401 (인증되지 않음) 상태 코드와 함께 응답해야 합니다. 클라이언트는 새로운 액세스 토큰을 요청하고 보호된 리소스 요청을 다시 시도할 수 있습니다.
```


insufficient_scope
```
불충분한 범위
요청이 액세스 토큰으로 제공된 권한보다 더 높은 권한이 필요한 경우에 발생합니다.

리소스 서버는 "insufficient_scope" 오류가 발생한 경우 HTTP 403 (금지됨) 상태 코드와 함께 응답해야 합니다. 또한 보호된 리소스에 액세스하기 위해 필요한 범위를 지정하는 "scope" 속성을 포함할 수 있습니다.
```

만약 요청시 인증 정보중 어느 하나라도 부족하면 예를 들어 클라이언트가 인증정보가 필요하다는 사실을 인지하지 못했거나 지원하지 않는 인증을 시도했을 때, 리소스 서버는 에러 코드나 에러 정보를 포함하는 것을 권장하지 않습니다.
아래 HTTP 응답은 서버가 권장하는 방법과 다르게 에러 정보가 포함되어 있으므로, 일부 사용자들은 이 응답을 잘못된 것으로 간주할 수 있습니다.
```
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="example"
```

## 엑세스 토큰 응답의 예시
보통은 베리어 토큰은 OAuth 2.0 엑세스 토큰 응답의 일부로 클라이언트에 반환됩니다. 예를 들면 다음과 같습니다.
```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
	"access_token":"mF_9.B5f-4.1JqM",
    "token_type":"Bearer",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA"
}
```


## 주석